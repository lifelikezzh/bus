C51 COMPILER V9.60.7.0   INTERRUPT                                                         12/18/2025 19:35:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE INTERRUPT
OBJECT MODULE PLACED IN .\Objects\interrupt.obj
COMPILER INVOKED BY: D:\keil\C51\BIN\C51.EXE interrupt.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\in
                    -terrupt.lst) OBJECT(.\Objects\interrupt.obj)

line level    source

   1          #include <REGX52.H>
   2          #include <interrupt.h>
   3          extern volatile unsigned char busindex;
   4          extern volatile unsigned char onesec;
   5          extern volatile unsigned char show10s;
   6          extern volatile unsigned char timer0Index;
   7          extern volatile unsigned char uartcmd[6];
   8          extern volatile unsigned char uartindex;
   9          extern volatile unsigned int bus1,bus2,bus3;
  10          volatile unsigned char pwmCount=0,pwmDuty=0;
  11          extern volatile unsigned char ledon;
  12          volatile unsigned char sendHelp=0,readCmd=0;
  13          void timer0_init(){
  14   1              TMOD&=0xF0;
  15   1              TMOD|=0x01;
  16   1              TL0=0x00;
  17   1              TH0=0x4C;
  18   1              TF0=0;
  19   1              TR0=1;
  20   1              ET0=1;
  21   1              EA=1;
  22   1              PT0=0;
  23   1      }
  24          void timer2_init() {
  25   1          RCAP2H=0xFF;
  26   1          RCAP2L=0x9C;
  27   1          TH2=0xFF;
  28   1          TL2=0x9C;
  29   1          T2CON=0;
  30   1          ET2=1;
  31   1          TR2=1;
  32   1          EA=1;
  33   1      }
  34          void UART_Init(){
  35   1              PCON&=0x7F;
  36   1              SCON=0x50;
  37   1              TMOD&=0x0F;
  38   1              TMOD|=0x20;
  39   1              TL1=0xFD;
  40   1              TH1=0xFD;
  41   1              ET1=0;
  42   1              TR1=1;
  43   1              ES=1;
  44   1      }
  45          
  46          void Ext_Init(){
  47   1              IT0=1;
  48   1              EX0=1;
  49   1              IT1=1;
  50   1              EX1=1;
  51   1      }
  52          void UART_SendByte(unsigned char Byte){
  53   1              ES=0;
  54   1              SBUF=Byte;
C51 COMPILER V9.60.7.0   INTERRUPT                                                         12/18/2025 19:35:19 PAGE 2   

  55   1              while(TI==0);
  56   1              TI=0;
  57   1              ES=1;
  58   1      }
  59          void UART_SendString(unsigned char *String){
  60   1              unsigned char g=0;
  61   1              while(String[g]!=0){
  62   2                      UART_SendByte(String[g]);
  63   2                      g++;
  64   2              }
  65   1      }
  66          void timer0_interrupt()interrupt 1
  67          {
  68   1              timer0Index++;
  69   1              TL0=0x00;TH0=0x4C;
  70   1              if(timer0Index>=20){
  71   2                      timer0Index=0;show10s++;onesec=1;
  72   2              }
  73   1      }
  74          void timer2_interrupt() interrupt 5
  75          {
  76   1          TF2=0;
  77   1          pwmCount++;
  78   1          if(pwmCount>=100){pwmCount=0;}
  79   1          if(pwmCount<pwmDuty && ledon==1){P2=0x00;}
  80   1              else{P2=0xFF;}
  81   1      }
  82          void INT1_Isr() interrupt 2
  83          {
  84   1              sendHelp=1;
  85   1      }
  86          void INT0_Isr() interrupt 0
  87          {
  88   1              EX0=0;
  89   1              busindex++;
  90   1              if(busindex>=4){busindex=0;}
  91   1      }
  92          void uart_interrupt()interrupt 4
  93          {
  94   1              if(RI==1){
  95   2                      unsigned char rec;
  96   2                      RI=0;
  97   2                      rec=SBUF;
  98   2                      if(rec!='\n'){uartcmd[uartindex]=rec;uartindex++;}
  99   2                      else{
 100   3                              readCmd=1;
 101   3                      }
 102   2              }
 103   1      }
 104          void UART_Loop()
 105          {
 106   1              if(sendHelp==1){
 107   2                      UART_SendString("HELP\n");
 108   2                      sendHelp=0;
 109   2              }
 110   1              if(readCmd==1){
 111   2                      if(uartcmd[0]=='Q' && uartcmd[1]==0){
 112   3                              UART_SendString("bus1: ");
 113   3                              UART_SendByte(bus1/60/10+'0');
 114   3                              UART_SendByte(bus1/60%10+'0');
 115   3                              UART_SendString(":");
 116   3                              UART_SendByte(bus1%60/10+'0');
C51 COMPILER V9.60.7.0   INTERRUPT                                                         12/18/2025 19:35:19 PAGE 3   

 117   3                              UART_SendByte(bus1%60%10+'0');
 118   3                              UART_SendString("\n");
 119   3                              UART_SendString("bus2: ");
 120   3                              UART_SendByte(bus2/60/10+'0');
 121   3                              UART_SendByte(bus2/60%10+'0');
 122   3                              UART_SendString(":");
 123   3                              UART_SendByte(bus2%60/10+'0');
 124   3                              UART_SendByte(bus2%60%10+'0');
 125   3                              UART_SendString("\n");
 126   3                              UART_SendString("bus3: ");
 127   3                              UART_SendByte(bus3/60/10+'0');
 128   3                              UART_SendByte(bus3/60%10+'0');
 129   3                              UART_SendString(":");
 130   3                              UART_SendByte(bus3%60/10+'0');
 131   3                              UART_SendByte(bus3%60%10+'0');
 132   3                              UART_SendString("\n");
 133   3                      }
 134   2                      else if(uartcmd[0]=='S'){
 135   3                              unsigned char which=uartcmd[1]-'0';
 136   3                              switch(which){
 137   4                                      case 1:
 138   4                                              bus1=(uartcmd[2]-'0')*100+(uartcmd[3]-'0')*10+uartcmd[4]-'0';
 139   4                                              break;
 140   4                                      case 2:
 141   4                                              bus2=(uartcmd[2]-'0')*100+(uartcmd[3]-'0')*10+uartcmd[4]-'0';
 142   4                                              break;
 143   4                                      case 3:
 144   4                                              bus3=(uartcmd[2]-'0')*100+(uartcmd[3]-'0')*10+uartcmd[4]-'0';
 145   4                                              break;
 146   4                                      default:
 147   4                                              UART_SendString("error\n");
 148   4                                              break;
 149   4                              }
 150   3                      }
 151   2                      uartindex=0;
 152   2                      uartcmd[0]=0;uartcmd[1]=0;uartcmd[2]=0;uartcmd[3]=0;uartcmd[4]=0;uartcmd[5]=0;
 153   2                      readCmd=0;
 154   2              }
 155   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    857    ----
   CONSTANT SIZE    =     38    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
